# Breakdown
We use a recursive generation function to generate all the possible strings from a rule. This is
very slow for part 1. Its usage in part 2 is much quicker, and in fact that insight could be used
to improve part 1 but then it would no longer work on the example input for part 1 which I want to
avoid.

Example input:
```q
x:"\n"vs"0: 4 1 5\n1: 2 3 | 3 2\n2: 4 4 | 5 5\n3: 4 5 | 5 4\n4: \"a\"\n5: \"b\"\n\nababbb\nbababa"
x,:"\n"vs"abbbab\naaabbb\naaaabbb"
```

## Common
For input parsing, we split into sections based on double newlines:
```q
q)p:"\n\n"vs"\n"sv x
q)p
"0: 4 1 5\n1: 2 3 | 3 2\n2: 4 4 | 5 5\n3: 4 5 | 5 4\n4: \"a\"\n5: \"b\""
"ababbb\nbababa\nabbbab\naaabbb\naaaabbb"
```
We split the first section to lines:
```q
q)"\n"vs p[0]
"0: 4 1 5"
"1: 2 3 | 3 2"
"2: 4 4 | 5 5"
"3: 4 5 | 5 4"
"4: \"a\""
"5: \"b\""
```
We split on `": "` to separate the head of each rule from the body:
```q
q)a:": "vs/:"\n"vs p[0]
q)a
,"0" "4 1 5"
,"1" "2 3 | 3 2"
,"2" "4 4 | 5 5"
,"3" "4 5 | 5 4"
,"4" "\"a\""
,"5" "\"b\""
```
We parse the heads as integers:
```q
q)num:"J"$a[;0]
q)num
0 1 2 3 4 5
```
We find which rules are for terminal symbols by looking for double quotes:
```q
q)t:"\""in/:a[;1]
q)t
000011b
```
The rule bodies are extracted in different ways depending on whether the rule is a terminal or a
branch. This can be expressed as a vector conditional. However, since the type of the rule body is
different (char vs list of list of long), we have to genericize the lists by prepending dummy
elements that force them to be general lists, then drop the first element:
```q
    1_?[t;(::), ... ;(::), ...]
```
For the terminal rules, we index into the string at index 1:
```q
q)1_?[0b,t;(::),a[;1;1];(::),a[;1]]
"4 1 5"
"2 3 | 3 2"
"4 4 | 5 5"
"4 5 | 5 4"
"a"
"b"
```
For the branch rules, we split them on `" | "`, then split each one on `" "` and parse them as long:
```q
q)r:1_?[0b,t;(::),a[;1;1];(::),"J"$" "vs/:/:" | "vs/:a[;1]]
q)r
,4 1 5
(2 3;3 2)
(4 4;5 5)
(4 5;5 4)
"a"
"b"
```
We put all of this into a table:
```q
q)r0:([num]t;r)
q)r0
num| t r
---| -----------
0  | 0 ,4 1 5
1  | 0 (2 3;3 2)
2  | 0 (4 4;5 5)
3  | 0 (4 5;5 4)
4  | 1 "a"
5  | 1 "b"
```
We retrieve the strings from the second section of the input:
```q
q)str:"\n"vs p 1
q)str
"ababbb"
"bababa"
"abbbab"
"aaabbb"
"aaaabbb"
```
The result of input parsing is the pair `(r0;str)`.

## Part 1
We generate all the possible strings from rule 0 and then check how many of the given strings are
in the generated ones.

The generation function takes the `r0` from the parsed input and a list of rules:
```q
    .d19.gen:{[r0;rules]
        ...
    };
```
The function is recursive. The base case is when we have no rules, then we return an empty string:
```q
    if[0=count rules; :enlist ""];
```
We fetch the details for the first rule in the list:
```q
    m:r0[first rules];
```
The next part is different depending on whether the rule is a terminal rule or a branch. For a
terminal, we recursively generate the possible strings for the remaining rules, then prepend the
terminal character:
```q
    $[m`t;m[`r],/:.d19.gen[r0;1_rules]; ... ]
```
For the branch case, we replace the first rule with each branch in the rule and then recursively
call the function to generate the possible strings for the replaced rule lists:
```q
    $[... ;raze .d19.gen[r0] each (m[`r],\:1_rules)]
```
The solution for part 1 consists of calling this function on the parsed input and then checking how
many of the input strings are in the list of possibilities.
```q
q)p:d19 x;r0:p 0;str:p 1
q)found:.d19.gen[r0;enlist 0]
q)found
"aaaabb"
"aaabab"
"abbabb"
"abbbab"
"aabaab"
"aabbbb"
"abaaab"
"ababbb"
q)str in found
10100b
q)sum str in found
2i
```

PART 2:
We generate the sets for rules 42 and 31, which is much quicker. The next part heavily depends on
some assumptions on the input. The rules must generate strings of the same length, there must be
no overlap between the sets generated by the two rules, and the input strings must be of lengths
that are multiples of the generated strings. With this in mind we find all prefixes that match
those generated by rule 42, and all suffixes that match those generated by rule 31. We count how
many such matches there are. For a string to be valid, at least one suffix must match, the
number of prefixes that match must be greater than the number of suffixes, and there must be no
chunk that doesn't match either a prefix or a suffix (or e.g. a prefix appearing after a suffix).
These conditions can be quickly checked from the match counts.

Example input:
```q
x:"\n"vs"42: 9 14 | 10 1\n9: 14 27 | 1 26\n10: 23 14 | 28 1\n1: \"a\"\n11: 42 31\n5: 1 14 | 15 1"
x,:"\n"vs"19: 14 1 | 14 14\n12: 24 14 | 19 1\n16: 15 1 | 14 14\n31: 14 17 | 1 13"
x,:"\n"vs"6: 14 14 | 1 14\n2: 1 24 | 14 4\n0: 8 11\n13: 14 3 | 1 12\n15: 1 | 14\n17: 14 2 | 1 7"
x,:"\n"vs"23: 25 1 | 22 14\n28: 16 1\n4: 1 1\n20: 14 14 | 1 15\n3: 5 14 | 16 1\n27: 1 6 | 14 18"
x,:"\n"vs"14: \"b\"\n21: 14 1 | 1 14\n25: 1 1 | 1 14\n22: 14 14\n8: 42\n26: 14 22 | 1 20"
x,:"\n"vs"18: 15 15\n7: 14 5 | 1 21\n24: 14 1\n"
x,:enlist"abbbbbabbbaaaababbaabbbbabababbbabbbbbbabaaaa"
x,:enlist"bbabbbbaabaabba"
x,:enlist"babbbbaabbbbbabbbbbbaabaaabaaa"
x,:enlist"aaabbbbbbaaaabaababaabababbabaaabbababababaaa"
x,:enlist"bbbbbbbaaaabbbbaaabbabaaa"
x,:enlist"bbbababbbbaaaaaaaabbababaaababaabab"
x,:enlist"ababaaaaaabaaab"
x,:enlist"ababaaaaabbbaba"
x,:enlist"baabbaaaabbaaaababbaababb"
x,:enlist"abbbbabbbbaaaababbbbbbaaaababb"
x,:enlist"aaaaabbaabaaaaababaa"
x,:enlist"aaaabbaaaabbaaa"
x,:enlist"aaaabbaabbaaaaaaabbbabbbaaabbaabaaa"
x,:enlist"babaaabbbaaabaababbaabababaaab"
x,:enlist"aabbbbbaabbbaaaaaabbbbbababaaaaabbaaabba"
```
We parse the input:
```q
q)p:d19 x;r0:p 0;str:p 1
```
We generate the possibilites for rules 42 and 31:
```q
q)found42:.d19.gen[r0;enlist 42]
q)found42
"babbb"
"baabb"
"bbaab"
"bbabb"
"bbbab"
"bbbbb"
"abbbb"
"aabbb"
"aaaab"
"aaabb"
"aaaba"
"ababa"
"bbbba"
"aaaaa"
"baaaa"
"bbaaa"
q)found31:.d19.gen[r0;enlist 31]
q)found31
"bbaba"
"bbbaa"
"babab"
"babaa"
"babba"
"baaba"
"baaab"
"ababb"
"abaab"
"abbab"
"abaaa"
"abbaa"
"abbba"
"aabab"
"aabaa"
"aabba"
```
We reject the input if there is an overlap between the two sets:
```q
    if[0<count found42 inter found31; '"unsupported input"]
```
We reject the input if not all of the strings are of the same length:
```q
    if[1<count distinct count each found42,found31; '"unsupported input"]
```
We cut the input strings to pieces based on the common length of the possible strings:
```q
q)bits:count[found42 0] cut/:str
q)bits
("abbbb";"babbb";"aaaab";"abbaa";"bbbba";"babab";"bbabb";"bbbba";"baaaa")
("bbabb";"bbaab";"aabba")
("babbb";"baabb";"bbbab";"bbbbb";"aabaa";"abaaa")
("aaabb";"bbbba";"aaaba";"ababa";"ababa";"bbaba";"aabba";"babab";"abaaa")
("bbbbb";"bbaaa";"abbbb";"aaabb";"abaaa")
("bbbab";"abbbb";"aaaaa";"aaabb";"ababa";"aabab";"aabab")
("ababa";"aaaaa";"baaab")
("ababa";"aaaab";"bbaba")
("baabb";"aaaab";"baaaa";"babba";"ababb")
("abbbb";"abbbb";"aaaab";"abbbb";"bbaaa";"ababb")
("aaaaa";"bbaab";"aaaaa";"babaa")
("aaaab";"baaaa";"bbaaa")
("aaaab";"baabb";"aaaaa";"aabbb";"abbba";"aabba";"abaaa")
("babaa";"abbba";"aabaa";"babba";"ababa";"baaab")
("aabbb";"bbaab";"bbaaa";"aaabb";"bbbab";"abaaa";"aabba";"aabba")
```
We check which of these bits can be derived from rule 42:
```q
q)bits in found42
111010111b
110b
111100b
111110000b
11110b
1111100b
110b
110b
11100b
111110b
1110b
111b
1111000b
000010b
11111000b
```
We find the index of the first `0b` in each list to find the prefix length:
```q
q)pre:(bits in found42)?\:0b
q)pre
3 2 4 5 4 5 2 2 3 5 3 3 4 0 5
```
We similarly find the postfix length by matching with the possibilites for rule 31. Since we are
looking from the back, we have to reverse the strings:
```q
q)post:(reverse each bits in found31)?\:0b
q)post
0 1 2 4 1 2 1 1 2 1 1 0 3 1 3
```
From these two numbers we can "implement" matching with rules 8 and 11:
* there must be at least one postfix (because rule 11 has a 31 at the end of both options)
```q
    (0<post)
```
* the number of prefixes must be strictly greater than the numer of postfixes (rule 11 has an equal
number of both, and rule 8 adds at least one more)
```q
    (pre>post)
``` 
* the total of the prefix and postfix length must add up to the length of the string (no bits that
don't match either rule nor a random mixture of 42- and 31-compliant rules in the middle)
```q
    (pre+post)=count each bits
```
The answer is the logical `and` of these conditions, which we can sum up thanks to vector
operations:
```q
q)sum(0<post) and (pre>post) and (pre+post)=count each bits
12i
```
